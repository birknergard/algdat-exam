# Task 2, Insertion Sort:

## Description


## PSEUDOCODE 
```
    List = unsorted list of elements

    // We start with the second element in the list, since we are comparing backwards.
    UnsortedElementIndex = 1

    WHILE UnsortedElementIndex < List.Length:
        IF List[UnsortedElementIndex] < List[UnsortedElementIndex - 1]: 
            // Store the unsorted element 
            UnsortedElement = List[UnsortedElementIndex]

            // Set comparison element to start position
            InsertionComparatorElementIndex = UnsortedElementIndex - 1

            WHILE InsertionComparatorElementIndex >= 0:
                
                // shift copy the new element forwards one index (to make space for unsorted element, or next shift) 
                List[InsertionComparatorElementIndex + 1] = List[InsertionComparatorElementIndex]

                IF List[InsertionComparatorElementIndex] <= UnsortedElement:
                    BREAK
                ELSE:
                    InsertionComparatorElementIndex--;
                ENDIF
                
                List[InsertionComparatorElementIndex + 1] = UnsortedElement;
            ENDWHILE

        ElSE:
            UnsortedElementIndex++;
        ENDIF
    ENDWHILE
```

## Time and space complexity
Time complexity should be big O(n^2) exponential time. The average case is also n^2 and the best case is n 
The algorithm (in the worst case, which is the signifier for big O) will check every element once for every element in the array.

## Task B
The time complexity of this algorithm will change slightly based on the order of the input. 
The best case for insertionsort is Ω(n), which occurs the the array is already sorted.
The reason for this being the best case is the the algorithm does not enter its inner loop if no elements are in the wrong order.

The worst case is O(n^2), where the array is in reverse order, which means every element is in the wrong position.
This means that the algoritm will enter its inner loop for every entry in the array.

The average case is Θ(n^2). In the average case the list will be neither in reverse nor sorted order. With a mix of sorted and unsorted data since the variance here is so large we have to assume that the algorithm is Θ(n^2) regardless of the data.  no way of knowing how much of the data is unsorted, and we ignore variance given its irrelevance when approaching infinity, we determine that the averge case time complexity is Θ(n^2).

Test with the implementation (average of 10 tests):
Standard order:
 -> Sort execution time: 985.27 ms (0.9853 s)
------> Operations:  540369286 

Shuffled:
-> Sort execution time: 1033.58 ms (1.0336 s)
------> Operations:  572161278 

## Sources:
https://en.wikipedia.org/wiki/Insertion_sort




        
        


